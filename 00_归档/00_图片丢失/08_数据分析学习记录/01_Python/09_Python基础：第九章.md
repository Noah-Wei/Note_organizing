# Python第九章：Python中的函数

## 一、函数的创建与调用

### 1.1 什么是函数

- 函数就是执行特定任务和特定功能的一段代码

### 1.2 为什么需要函数

- 复用代码
- 隐藏实现细节
- 提高程序的可维护性
- 提高程序的可读性，易于调试

### 1.3 函数的创建

```python
def 函数名([输入参数])：
	函数体
	[return xxx]
```

### 1.4 函数的调用

```python
函数名([实际参数])
```

**代码演示**

```python
def calc(a, b):
    c = a + b
    return c


result = calc(10, 20)
print(result)
```

## 二、函数的参数传递

> 形参的位置是在函数的定义处
>
> 实参的位置是在函数的调用处
>
> 形参和实参的名字可以不相同

### 2.1 位置实参

- **根据形参对应的位置进行参数传递**
- 图示

![image-20230506200826294](https://lskypro-1309218011.cos.ap-shanghai.myqcloud.com/2023/05/06/645643416b825.png)

### 2.2 关键字实参

- **根据形参名称进行实参传递**
- 图示

![image-20230506201009121](https://lskypro-1309218011.cos.ap-shanghai.myqcloud.com/2023/05/06/645643a125b2a.png)

**代码演示**

```python
def calc(a, b):  # a,b 为形参，形参的位置是在函数的定义处
    c = a + b
    return c


result = calc(10, 20)  # 10,20 为实参，实参的位置在函数的调用处
print(result)

result2 = calc(b=10, a=20)  # 关键字参数，=左侧的变量名称为关键字参数
print(result2)
```

### 2.3 参数传递的内存分析图

```
在函数调用过程中，进行参数的传递
如果是不可变对象，在函数体的修改不会影响实参的值    如：arg1的修改为100，不会影响n1的值
如果是可变对象，在函数体内的修改会影响实参的值     如：arg2的修改 append(10),会影响到n2的值
```

![image-20230506201325782](https://lskypro-1309218011.cos.ap-shanghai.myqcloud.com/2023/05/06/64564465de6b4.png)

**代码演示**

```python
def fun(arg1, arg2):
    print('arg1:', arg1)
    print('arg2:', arg2)
    arg1 = 100
    arg2.append(10)
    print('arg1:', arg1)
    print('arg2:', arg2)


n1 = 11
n2 = [22, 33, 44]
print('函数输入前：-----------')
print('n1:', n1)
print('n2:', n2)

fun(n1, n2)  # 位置传参，arg1，arg2为函数定义处的形参，n1,n2为函数调用处的实参
print('函数输入后：-----------')
print('n1:', n1)
print('n2:', n2)
```

## 三、函数的返回值

> 函数在定义时，是否需要返回值，视情况而定

- 函数的返回值
  - 如果函数没有返回值【函数执行完成之后，不需要给调用处提供数据】 return 可以省略不写
  - 如果函数的返回值，只有1个，直接返回类型
  - 如果函数的返回值，是有多个，返回的结果为 元祖

## 四、函数的参数定义

### 4.1 函数定义默认值参数

- 函数定义时，给形参设置默认值，只有与默认值不符的时候才需要传递实参

**代码演示**

```python
def fun(a, b=10):  # b为默认值参数
    print(a, b)


# 函数的调用
fun(100)  # a=100,b=10,    b采用默认值
fun(20, 30)  # a=20,b=30    b默认值不符的时候才需要传递实参
```

### 4.2 个数可变的位置参数

- 定义函数时，可能无法事先确定传递的位置参数个数时，可使用可变的位置参数
- 个数可变的位置参数**只能定义一个**
- 使用`*`定义个数可变的位置形参
- 结果为一个**元祖**

**代码演示**

```python
def fun(*args):  # 函数定义时，可变的位置参数
    print(args)


# 传递1个参数
fun(10)
# 传递2个参数
fun(20, 20)
# 传递3个参数
fun(20, 20, 20)
```

### 4.3 个数可变的关键字参数

- 定义函数时，可能无法事先确定传递的关键字参数个数时，可使用可变的关键字参数
- 个数可变的关键字参数**只能定义一个**
- 使用`**`定义个数可变的关键字形参
- 结果为一个**字典**
- 在一个函数的定义过程当中，既有个数可变的关键字形参，也有个数可变的位置形参；要求`个数可变的关键字形参`放在`个数可变的位置形参`之前。即`def fun3(*args, **kwargs):`

**代码演示**

```python
def fun1(**args):
    print(args)


# 传递1个参数
fun1(a=10)
# 传递3个参数
fun1(a=20, b=3, c=40)
```

### 4.4 总结

| 序号 | 参数的类型                             | 函数的定义 | 函数的调用 | 备注    |
| ---- | -------------------------------------- | ---------- | ---------- | ------- |
| 1    | 位置实参                               |            | √          |         |
|      | 将序列中的每个元素都转换为位置实参     |            | √          | 使用 *  |
| 2    | 关键字实参                             |            | √          |         |
|      | 将字典中的每个键值对都转换成关键字实参 |            | √          | 使用 ** |
| 3    | 默认值形参                             | √          |            |         |
| 4    | 关键字形参                             | √          |            | 使用 *  |
| 5    | 个数可变的位置形参                     | √          |            | 使用 *  |
| 6    | 个数可变的关键字形参                   | √          |            | 使用 ** |

**代码演示**

```python
def fun(a, b, c):  # a,b,c在函数的定义处，所以是形参
    print('a=', a)
    print('b=', b)
    print('c=', c)


# 函数的调用
fun(10, 20, 30)  # 函数调用时的参数传递，成为位置传参，实参
lst = [11, 22, 33]
# fun(lst)  # 报错
fun(*lst)  # 在函数调用时，将列表中的每个元素都转换成位置实参传入

fun(a=100, b=200, c=300)  # 函数的调用，关键字实参
dic = {'a': 111, 'b': 222, 'c': 333}
fun(**dic)  # 在函数调用时，将子弹中的键值对都转换成位置实参传入
```

## 五、函数的作用域

**作用域**

- 程序代码能访问该变量的区域
- 根据变量的有效范围可分为
  - 局部变量
    - 在函数内定义并使用的变量，只在函数内部有效
    - 局部变量使用`global`声明，这个声明就会成全局变量
  - 全局变量
    - 函数体外定义的变量，可作用于函数内外

**代码演示**

```python
def fun(a, b):
    c = a + b  # c,就称为局部变量，因为c在是函数体内进行定义的变量,a,b为函数的形参，作用范围也是函数内部，相当于局部变量
    print(c)


# print(c)  ,因为a,c超出了起作用的范围（超出了作用域）
# print(a)

name = 'eden'  # name的作用范围为函数内部和外部都可以使用 -->称为全局变量
print(name)


def fun2():
    print(name)


# 调用函数
fun2()


def fun3():
    global age  # 函数内部定义的变量，局部变量，局部变量使用global声明，这个变量实际上就变成了全局变量
    age = 20
    print(age)


fun3()
print(age)
```

## 六、递归函数

- 什么是递归函数
  - 如果在一个函数的函数体内调用了该函数本身，这个函数就成为递归函数
- 递归的组成部分
  - 递归调用与递归终止条件
- 递归的调用过程
  - 每递归调用一次函数，都会在栈内存分配一个栈帧
  - 每执行一次函数，都会释放相应的空间
- 递归的优缺点
  - 优点：占用内存多，效率低下
  - 缺点：思路和代码简单

### 6.1 使用递归来计算阶乘

**图示**

![image-20230510140432909](https://lskypro-1309218011.cos.ap-shanghai.myqcloud.com/2023/05/10/645b33f60e24a.png)

**代码演示**

```python
def fac(n):  # n为要计算阶乘的数
    if n == 1:
        return 1
    else:
        return n * fac(n - 1)


print(fac(6))
```

### 6.2 斐波那契数列

```
1	1	2	3	5	8	13
第1、2项的数为1
第n项的数为（n-1）的值+（n-2）的值

```

```python
def fib(n):
    if n == 1:
        return 1
    elif n == 2:
        return 2
    else:
        return fib(n - 1) + fib(n - 2)


# 裴波那契数列的第6位上的数
print(fib(6))

# 输出数列的前6为上的数
for i in range(1, 7):
    print(fib(i))

# 输出数列的前6为上的数,并存放在一个列表值
list = []
for i in range(1, 7):
    list.append(fib(i))
print(list)
```